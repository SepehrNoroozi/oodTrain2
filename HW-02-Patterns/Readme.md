# تمرین شماره ۲ – الگوهای طراحی
## سیستم مدیریت درخواست‌های پشتیبانی (Ticketing System)

### نفر اول: سپهر نوروزی چاکلی
### نفر دوم محمدمهدی حسنی

---

## بخش ۱: تشخیص زیرمسائل و الگوهای طراحی

در کد اولیه‌ی ارائه‌شده، سیستم مدیریت درخواست‌های پشتیبانی به‌صورت رویه‌ای و با استفاده‌ی گسترده از شرط‌های تو در تو پیاده‌سازی شده است.  
با افزایش تعداد وضعیت‌ها، نوع درخواست‌ها و کانال‌های ورودی، نگهداری و توسعه‌ی این کد بسیار دشوار خواهد شد.  
در ادامه، زیرمسائل اصلی سیستم شناسایی شده و برای هر کدام، الگوی طراحی مناسب پیشنهاد می‌شود.

### ۱. مدیریت وضعیت‌های Ticket (State Pattern) (سپهر نوروزی)

در سیستم مدیریت درخواست‌های پشتیبانی، هر Ticket در طول چرخه‌ی عمر خود وضعیت‌های متوالی مختلفی را طی می‌کند.  
در کد اولیه، این وضعیت‌ها به‌صورت مقادیر رشته‌ای مانند زیر پیاده‌سازی شده‌اند:

- NEW
- ASSIGNED
- IN_PROGRESS
- RESOLVED
- CLOSED

رفتار سیستم در متد `handle` از کلاس `TicketService`، وابسته به وضعیت فعلی Ticket است و با استفاده از شرط‌های متوالی `if` کنترل می‌شود.  
به عنوان مثال، در هر وضعیت:
- پیام‌های متفاوتی چاپ می‌شود
- عملیات متفاوتی انجام می‌گیرد
- و وضعیت Ticket تغییر می‌کند

این شیوه‌ی پیاده‌سازی مشکلات زیر را ایجاد می‌کند:
- افزایش شرط‌های تو در تو با اضافه شدن هر وضعیت جدید
- کاهش خوانایی و نگهداری‌پذیری کد
- نقض اصل **Open/Closed Principle (OCP)**، زیرا برای افزودن وضعیت جدید، نیاز به تغییر کد موجود است
- وابستگی شدید منطق پردازش به مقادیر رشته‌ای وضعیت

#### الگوی پیشنهادی: State

برای حل این مسئله، استفاده از **الگوی State** مناسب است؛ زیرا رفتار Ticket مستقیماً به وضعیت فعلی آن وابسته است و هر وضعیت، منطق رفتاری مخصوص به خود را دارد.

در این الگو:
- هر وضعیت به‌صورت یک کلاس مجزا پیاده‌سازی می‌شود
- تغییر وضعیت بدون استفاده از شرط‌های `if/else` انجام می‌گیرد
- رفتارهای وابسته به وضعیت، از کلاس `TicketService` جدا می‌شوند

#### روش اعمال الگو

برای اعمال الگوی State در این سیستم:
- یک اینترفیس (مانند `TicketState`) برای تعریف رفتار مشترک وضعیت‌ها ایجاد می‌شود.
- برای هر وضعیت Ticket (NEW، ASSIGNED، IN_PROGRESS، RESOLVED، CLOSED) یک کلاس جداگانه پیاده‌سازی می‌شود.
- کلاس `Ticket` به‌جای نگه‌داری وضعیت به‌صورت `String`، یک reference از نوع `TicketState` نگه می‌دارد.
- منطق تغییر وضعیت و رفتار وابسته به آن، از کلاس `TicketService` به کلاس‌های مربوط به وضعیت منتقل می‌شود.

در نتیجه‌ی این بازطراحی:
- کلاس `TicketService` ساده‌تر می‌شود
- افزودن وضعیت جدید بدون تغییر کدهای قبلی امکان‌پذیر خواهد بود
- طراحی سیستم از نظر شی‌گرایی و اصول SOLID بهبود پیدا می‌کند


### ۲. نحوه‌ی پردازش Ticket بر اساس نوع درخواست
(توسط محمدمهدی حسنی تکمیل می‌شود)

### ۳. ایجاد و ساخت Ticket (Factory Pattern) (سپهر نوروزی)

در کد اولیه، ایجاد و مقداردهی اولیه‌ی Ticket به صورت پراکنده و وابسته به مقادیر رشته‌ای انجام می‌شود.  
برای ساخت Ticket، مقادیر channel و type به صورت مستقیم به سازنده داده می‌شوند و در بخش‌های مختلف برنامه، ساخت اشیا Ticket ممکن است به شیوه‌های متفاوت انجام شود.

این شیوه‌ی پیاده‌سازی باعث مشکلات زیر می‌شود:
- وابستگی مستقیم ساخت Ticket به مقادیر رشته‌ای (برای channel و type)
- خطر ورود داده‌ی نامعتبر یا غلط (در نبود اعتبارسنجی)
- سخت شدن اعمال تغییرات ساختاری در فرآیند ساخت
- کاهش خوانایی و نگهداری‌پذیری کد

#### الگوی پیشنهادی: Factory

برای حل این مسئله، استفاده از **الگوی Factory** مناسب است؛ زیرا ساخت Ticket ممکن است وابسته به شرایط مختلف یا پارامترهای ورودی باشد و نیاز داریم فرآیند ساخت را به صورت انعطاف‌پذیر و قابل کنترل پیاده کنیم.

در این الگو:
- وظیفه‌ی ساخت اشیا به کلاس Factory سپرده می‌شود
- اعتبارسنجی و انتخاب سازنده‌ی مناسب، در Factory انجام می‌شود
- انتقال وابستگی‌ها و جلوگیری از پراکندگی منطق ساخت به کدهای مختلف

#### روش اعمال الگو

برای اعمال الگوی Factory در این سیستم:
- یک کلاس یا اینترفیس Factory (مثلاً `TicketFactory`) ایجاد می‌شود که مسئول ساخت و مقداردهی اولیه‌ی اشیا Ticket است.
- فرآیند ساخت، شامل اعتبارسنجی channel و type و مقداردهی اولیه مناسب می‌شود.
- در صورت نیاز به ساخت Ticket با شرایط خاص یا انواع متفاوت، Factory قابل توسعه خواهد بود.

در نتیجه‌ی این بازطراحی:
- ساخت Ticket استاندارد و قابل کنترل خواهد بود
- افزودن انواع Ticket بدون تغییر کدهای قبلی امکان‌پذیر می‌شود
- اعتبارسنجی ورودی‌ها و مدیریت وابستگی‌ها بهبود می‌یابد


### ۴. ثبت رویدادها (Logging)
(توسط محمدمهدی حسنی تکمیل می‌شود)
