# تمرین شماره ۲ – الگوهای طراحی
## سیستم مدیریت درخواست‌های پشتیبانی (Ticketing System)

### نفر اول: سپهر نوروزی چاکلی
### نفر دوم محمدمهدی حسنی

---

## بخش ۱: تشخیص زیرمسائل و الگوهای طراحی

در کد اولیه‌ی ارائه‌شده، سیستم مدیریت درخواست‌های پشتیبانی به‌صورت رویه‌ای و با استفاده‌ی گسترده از شرط‌های تو در تو پیاده‌سازی شده است.  
با افزایش تعداد وضعیت‌ها، نوع درخواست‌ها و کانال‌های ورودی، نگهداری و توسعه‌ی این کد بسیار دشوار خواهد شد.  
در ادامه، زیرمسائل اصلی سیستم شناسایی شده و برای هر کدام، الگوی طراحی مناسب پیشنهاد می‌شود.

### ۱. مدیریت وضعیت‌های Ticket (State Pattern) (سپهر نوروزی)

در سیستم مدیریت درخواست‌های پشتیبانی، هر Ticket در طول چرخه‌ی عمر خود وضعیت‌های متوالی مختلفی را طی می‌کند.  
در کد اولیه، این وضعیت‌ها به‌صورت مقادیر رشته‌ای مانند زیر پیاده‌سازی شده‌اند:

- NEW
- ASSIGNED
- IN_PROGRESS
- RESOLVED
- CLOSED

رفتار سیستم در متد `handle` از کلاس `TicketService`، وابسته به وضعیت فعلی Ticket است و با استفاده از شرط‌های متوالی `if` کنترل می‌شود.  
به عنوان مثال، در هر وضعیت:
- پیام‌های متفاوتی چاپ می‌شود
- عملیات متفاوتی انجام می‌گیرد
- و وضعیت Ticket تغییر می‌کند

این شیوه‌ی پیاده‌سازی مشکلات زیر را ایجاد می‌کند:
- افزایش شرط‌های تو در تو با اضافه شدن هر وضعیت جدید
- کاهش خوانایی و نگهداری‌پذیری کد
- نقض اصل **Open/Closed Principle (OCP)**، زیرا برای افزودن وضعیت جدید، نیاز به تغییر کد موجود است
- وابستگی شدید منطق پردازش به مقادیر رشته‌ای وضعیت

#### الگوی پیشنهادی: State

برای حل این مسئله، استفاده از **الگوی State** مناسب است؛ زیرا رفتار Ticket مستقیماً به وضعیت فعلی آن وابسته است و هر وضعیت، منطق رفتاری مخصوص به خود را دارد.

در این الگو:
- هر وضعیت به‌صورت یک کلاس مجزا پیاده‌سازی می‌شود
- تغییر وضعیت بدون استفاده از شرط‌های `if/else` انجام می‌گیرد
- رفتارهای وابسته به وضعیت، از کلاس `TicketService` جدا می‌شوند

#### روش اعمال الگو

برای اعمال الگوی State در این سیستم:
- یک اینترفیس (مانند `TicketState`) برای تعریف رفتار مشترک وضعیت‌ها ایجاد می‌شود.
- برای هر وضعیت Ticket (NEW، ASSIGNED، IN_PROGRESS، RESOLVED، CLOSED) یک کلاس جداگانه پیاده‌سازی می‌شود.
- کلاس `Ticket` به‌جای نگه‌داری وضعیت به‌صورت `String`، یک reference از نوع `TicketState` نگه می‌دارد.
- منطق تغییر وضعیت و رفتار وابسته به آن، از کلاس `TicketService` به کلاس‌های مربوط به وضعیت منتقل می‌شود.

در نتیجه‌ی این بازطراحی:
- کلاس `TicketService` ساده‌تر می‌شود
- افزودن وضعیت جدید بدون تغییر کدهای قبلی امکان‌پذیر خواهد بود
- طراحی سیستم از نظر شی‌گرایی و اصول SOLID بهبود پیدا می‌کند

### ۲. نحوه‌ی پردازش Ticket بر اساس نوع درخواست (Strategy Pattern) (محمدمهدی حسنی)

در کد اولیه، نحوه‌ی پردازش Ticket و ارسال پاسخ به آن، وابسته به نوع درخواست (Type) است.  
در حال حاضر، دو نوع درخواست در سیستم وجود دارد:

- BUG
- سایر درخواست‌ها (Generic)

در کلاس `TicketService` و به‌ویژه در وضعیت‌های `ASSIGNED` و `IN_PROGRESS`، با استفاده از شرط‌های `if` بررسی می‌شود که آیا نوع Ticket برابر `BUG` است یا خیر، و بر اساس آن:
- Ticket به واحد متفاوتی اختصاص داده می‌شود
- پاسخ متفاوتی برای آن ارسال می‌شود

این نوع پیاده‌سازی باعث بروز مشکلات زیر می‌شود:
- وابستگی مستقیم منطق پردازش به مقدار رشته‌ای نوع Ticket
- سخت شدن افزودن نوع جدید درخواست (مانند FEATURE یا SUPPORT)
- نقض اصل **Open/Closed Principle (OCP)** به دلیل نیاز به تغییر کدهای موجود
- افزایش شرط‌های تودرتو در کلاس `TicketService`
- سیستم از نظر انعطاف‌پذیری و توسعه‌پذیری بهبود پیدا می‌کند

#### الگوی پیشنهادی: Strategy

برای حل این مسئله، استفاده از **الگوی Strategy** مناسب است؛ زیرا پردازش Ticket می‌تواند به روش‌های مختلفی انجام شود که همگی یک هدف مشترک دارند اما پیاده‌سازی متفاوتی دارند.

در این الگو:
- برای هر نوع پردازش، یک Strategy مجزا تعریف می‌شود
- انتخاب نوع پردازش، در زمان اجرا انجام می‌شود
- شرط‌های `if/else` حذف می‌شوند

#### روش اعمال الگو

برای اعمال الگوی Strategy در این سیستم:
- یک اینترفیس (مانند `TicketHandlerStrategy`) برای تعریف عملیات پردازش Ticket ایجاد می‌شود.
- برای هر نوع درخواست (BUG، Generic و …) یک کلاس مجزا پیاده‌سازی می‌شود.
- کلاس `TicketService` به‌جای تصمیم‌گیری مستقیم درباره‌ی نوع پردازش، از Strategy مناسب استفاده می‌کند.
- انتخاب Strategy بر اساس نوع Ticket انجام می‌شود.

در نتیجه‌ی این بازطراحی:
- افزودن نوع جدید درخواست بدون تغییر در کدهای قبلی امکان‌پذیر می‌شود
- کلاس `TicketService` ساده‌تر و خواناتر می‌شود### ۳. ایجاد و ساخت Ticket (Factory Pattern) (سپهر نوروزی)

در کد اولیه، ایجاد و مقداردهی اولیه‌ی Ticket به صورت پراکنده و وابسته به مقادیر رشته‌ای انجام می‌شود.  
برای ساخت Ticket، مقادیر channel و type به صورت مستقیم به سازنده داده می‌شوند و در بخش‌های مختلف برنامه، ساخت اشیا Ticket ممکن است به شیوه‌های متفاوت انجام شود.

این شیوه‌ی پیاده‌سازی باعث مشکلات زیر می‌شود:
- وابستگی مستقیم ساخت Ticket به مقادیر رشته‌ای (برای channel و type)
- خطر ورود داده‌ی نامعتبر یا غلط (در نبود اعتبارسنجی)
- سخت شدن اعمال تغییرات ساختاری در فرآیند ساخت
- کاهش خوانایی و نگهداری‌پذیری کد

#### الگوی پیشنهادی: Factory

برای حل این مسئله، استفاده از **الگوی Factory** مناسب است؛ زیرا ساخت Ticket ممکن است وابسته به شرایط مختلف یا پارامترهای ورودی باشد و نیاز داریم فرآیند ساخت را به صورت انعطاف‌پذیر و قابل کنترل پیاده کنیم.

در این الگو:
- وظیفه‌ی ساخت اشیا به کلاس Factory سپرده می‌شود
- اعتبارسنجی و انتخاب سازنده‌ی مناسب، در Factory انجام می‌شود
- انتقال وابستگی‌ها و جلوگیری از پراکندگی منطق ساخت به کدهای مختلف

#### روش اعمال الگو

برای اعمال الگوی Factory در این سیستم:
- یک کلاس یا اینترفیس Factory (مثلاً `TicketFactory`) ایجاد می‌شود که مسئول ساخت و مقداردهی اولیه‌ی اشیا Ticket است.
- فرآیند ساخت، شامل اعتبارسنجی channel و type و مقداردهی اولیه مناسب می‌شود.
- در صورت نیاز به ساخت Ticket با شرایط خاص یا انواع متفاوت، Factory قابل توسعه خواهد بود.

در نتیجه‌ی این بازطراحی:
- ساخت Ticket استاندارد و قابل کنترل خواهد بود
- افزودن انواع Ticket بدون تغییر کدهای قبلی امکان‌پذیر می‌شود
- اعتبارسنجی ورودی‌ها و مدیریت وابستگی‌ها بهبود می‌یابد

### ۴. ثبت رویدادها (Logging) (محمدمهدی حسنی)

در کد اولیه، در انتهای متد `handle` از کلاس `TicketService`، عملیات ثبت رویداد (Log) به‌صورت مستقیم و با استفاده از دستور `System.out.println` انجام می‌شود:

- ثبت پیام مربوط به پردازش Ticket
- چاپ شناسه‌ی Ticket و وضعیت نهایی آن

این شیوه‌ی پیاده‌سازی مشکلات زیر را ایجاد می‌کند:
- وابستگی مستقیم منطق اصلی سیستم به نحوه‌ی Logging
- سخت شدن تغییر مکانیزم ثبت رویداد (مثلاً ذخیره در فایل یا پایگاه داده)
- تکرار کد Logging در صورت نیاز در بخش‌های دیگر
- نقض اصل **Single Responsibility Principle (SRP)**، زیرا کلاس `TicketService` بیش از یک مسئولیت بر عهده دارد

#### الگوی پیشنهادی: Decorator (یا Observer ساده)

برای حل این مسئله، می‌توان از الگوی **Decorator** (و در سطح ساده‌تر، Observer) استفاده کرد تا منطق Logging از منطق اصلی پردازش Ticket جدا شود.

در این رویکرد:
- عملیات Logging به‌عنوان یک رفتار جانبی (Cross-Cutting Concern) در نظر گرفته می‌شود
- بدون تغییر در منطق اصلی پردازش Ticket، امکان افزودن یا حذف Logging وجود دارد
- وابستگی به `System.out.println` از منطق اصلی حذف می‌شود

#### روش اعمال الگو

برای اعمال این الگو در سیستم:
- یک اینترفیس یا کلاس پایه برای پردازش Ticket تعریف می‌شود.
- یک Decorator برای افزودن قابلیت Logging ایجاد می‌شود که پردازش اصلی را wrap می‌کند.
- ثبت رویداد پس از انجام عملیات اصلی انجام می‌شود.
- در صورت نیاز، می‌توان چند Decorator مختلف برای انواع Logging اضافه کرد.

در نتیجه‌ی این بازطراحی:
- منطق پردازش Ticket از منطق Logging جدا می‌شود
- تغییر یا توسعه‌ی سیستم Logging بدون تغییر کدهای اصلی امکان‌پذیر خواهد بود
- طراحی سیستم از نظر رعایت اصول SOLID بهبود می‌یابد