## بخش ۴ – تحلیل شی‌گرا (SOLID + PLK + CRP)

در نسخه‌ی اولیه‌ی سیستم، بیشتر منطق مربوط به پردازش Ticketها داخل کلاس `TicketService` و با استفاده از شرط‌های متعدد `if/else` پیاده‌سازی شده بود. این موضوع باعث شده بود که کلاس‌ها مسئولیت‌های زیادی داشته باشند و با تغییر در یکی از بخش‌ها، نیاز به تغییر در قسمت‌های دیگر نیز به وجود بیاید. به همین دلیل، نگه‌داری و توسعه‌ی سیستم در این حالت دشوار بود.  
پس از بازطراحی سیستم با استفاده از الگوهای **State، Strategy و Factory**، ساختار کد از نظر اصول شی‌گرایی بهبود قابل توجهی پیدا کرده است.

### اصل SRP (Single Responsibility Principle)
در طراحی اولیه، کلاس `TicketService` وظایف مختلفی مانند مدیریت وضعیت Ticket، تعیین نوع پاسخ، بررسی نوع درخواست و ثبت لاگ را هم‌زمان انجام می‌داد.  
بعد از اعمال الگوها، هر مسئولیت به بخش مخصوص خود منتقل شد؛ Stateها مسئول تغییر وضعیت Ticket هستند، Strategyها نحوه‌ی پاسخ‌دهی را مشخص می‌کنند و Factoryها وظیفه‌ی ساخت اشیاء را بر عهده دارند.  
در نتیجه هر کلاس تنها یک مسئولیت مشخص دارد و اصل SRP بهتر رعایت شده است.

### اصل OCP (Open/Closed Principle)
در نسخه‌ی اولیه، اضافه‌کردن یک وضعیت جدید یا یک نوع پاسخ جدید نیازمند تغییر مستقیم در کد `TicketService` و افزودن شرط‌های جدید بود.  
در طراحی جدید، با اضافه‌کردن یک State یا Strategy جدید، بدون تغییر در منطق اصلی سیستم و فقط با اضافه‌کردن کلاس جدید (و در صورت نیاز به‌روزرسانی Factory)، می‌توان رفتار سیستم را گسترش داد.  
به این ترتیب سیستم برای توسعه باز و برای تغییر بسته شده است.

### اصل LSP (Liskov Substitution Principle)
تمامی Stateها اینترفیس `TicketState` را پیاده‌سازی می‌کنند و می‌توانند بدون ایجاد مشکل، جایگزین یکدیگر شوند.  
همچنین Strategyهای مختلف پاسخ‌دهی همگی از اینترفیس `TicketResponseStrategy` استفاده می‌کنند.  
به همین دلیل، جایگزینی یک پیاده‌سازی به‌جای پیاده‌سازی دیگر باعث تغییر غیرمنتظره در رفتار سیستم نمی‌شود و اصل LSP رعایت شده است.

### اصل ISP (Interface Segregation Principle)
در سیستم بازطراحی‌شده، اینترفیس‌ها ساده و هدفمند طراحی شده‌اند.  
برای مثال، `TicketState` فقط شامل متدهای مربوط به وضعیت Ticket است و `TicketResponseStrategy` فقط رفتار مربوط به پاسخ‌دهی را مشخص می‌کند.  
در نتیجه، کلاس‌ها مجبور به پیاده‌سازی متدهایی که به آن‌ها نیازی ندارند نیستند.

### اصل DIP (Dependency Inversion Principle)
در طراحی جدید، وابستگی کلاس‌ها از پیاده‌سازی‌های concrete به abstractionها منتقل شده است.  
کلاس‌ها به اینترفیس‌های State و Strategy وابسته هستند و ایجاد اشیاء concrete از طریق Factory انجام می‌شود.  
این موضوع باعث کاهش coupling و افزایش انعطاف‌پذیری سیستم شده است.

### اصل PLK (Principle of Least Knowledge)
در نسخه‌ی اولیه، کلاس `TicketService` از جزئیات داخلی Ticket و وضعیت‌های مختلف آن آگاهی زیادی دا.  
پس از بازطراحی، هر کلاس فقط با abstractionهای مورد نیاز خود در ارتباط است و از جزئیات داخلی بخش‌های دیگر اطلاعی ندارد.  
به این ترتیب، اصل کمترین آگاهی بهتر رعایت شده و خوانایی کد افزایش یافته است.

### اصل CRP (Common Reuse Principle)
در طراحی جدید، کلاس‌هایی که با هم تغییر می‌کنند در پکیج‌های مشخص و مرتبط (State، Strategy و Factory) قرار گرفته‌اند.  
این کار باعث شده تغییر در یک بخش، کمترین تأثیر را روی بخش‌های نامرتبط سیستم داشته باشد و استفاده