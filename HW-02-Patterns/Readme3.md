## فاز ۳ – اعمال الگوهای طراحی (State, Strategy, Factory)

در این فاز، الگوهای طراحی پیشنهادی که در فاز قبل شناسایی شدند، روی کد اولیه‌ی سیستم اعمال شده‌اند. هدف اصلی این بازطراحی، کاهش پیچیدگی کلاس `TicketService`، حذف شرط‌های تو در تو و افزایش انعطاف‌پذیری سیستم برای تغییرات آینده بوده است.

---

### 3-1 اعمال الگوی State

#### وضعیت در کد اولیه
در نسخه‌ی اولیه، وضعیت Ticket به‌صورت یک `String` در کلاس `Ticket` نگه‌داری می‌شد و تمام منطق مربوط به تغییر وضعیت‌ها در کلاس `TicketService` و با استفاده از شرط‌های متوالی `if` پیاده‌سازی شده بود.  
به عنوان مثال، رفتار سیستم در وضعیت‌های `NEW`، `ASSIGNED`، `IN_PROGRESS`، `RESOLVED` و `CLOSED` همگی در یک متد (`handle`) متمرکز شده بودند.

این موضوع باعث شده بود که:
- کلاس `TicketService` بسیار بزرگ و پیچیده شود
- اضافه‌کردن یک وضعیت جدید نیازمند تغییر مستقیم در این کلاس باشد
- خوانایی و نگه‌داری کد کاهش یابد

#### تغییرات انجام‌شده
برای حل این مشکل، الگوی **State** اعمال شد.  
ابتدا یک اینترفیس به نام `TicketState` تعریف شد و برای هر وضعیت، یک کلاس جداگانه پیاده‌سازی گردید:

- `NewState`
- `AssignedState`
- `InProgressState`
- `ResolvedState`
- `ClosedState`

هر یک از این کلاس‌ها مسئول رفتار Ticket در همان وضعیت خاص هستند و منطق تغییر وضعیت بعدی نیز در همان کلاس انجام می‌شود.  
در نتیجه، مسئولیت مدیریت وضعیت‌ها از `TicketService` حذف شده و به خود Stateها منتقل شده است.

---

### 3-2 اعمال الگوی Strategy

#### وضعیت در کد اولیه
در کد اولیه، نوع پاسخ‌دهی به Ticket در وضعیت `IN_PROGRESS` بر اساس نوع Ticket (`BUG` یا سایر موارد) و با استفاده از شرط `if/else` انجام می‌شد.  
این موضوع باعث وابستگی مستقیم منطق پاسخ‌دهی به نوع Ticket شده بود.

#### تغییرات انجام‌شده
برای مدیریت این بخش، الگوی **Strategy** استفاده شد.  
ابتدا یک اینترفیس به نام `TicketResponseStrategy` تعریف شد و سپس دو پیاده‌سازی برای آن ایجاد گردید:

- `BugResponseStrategy`
- `GenericResponseStrategy`

در وضعیت `InProgressState`، به‌جای استفاده از شرط‌های مستقیم، از Strategy مناسب برای ارسال پاسخ استفاده می‌شود.  
این کار باعث شده که اضافه‌کردن یک نوع پاسخ جدید، بدون تغییر در منطق Stateها امکان‌پذیر باشد.

---

### 3-3 اعمال الگوی Factory

#### هدف استفاده از Factory
پس از اعمال State و Strategy، همچنان در برخی قسمت‌ها نیاز به ایجاد مستقیم اشیاء concrete وجود داشت.  
برای کاهش وابستگی به `new` و افزایش انعطاف‌پذیری سیستم، از الگوی **Factory** استفاده شد.

#### تغییرات انجام‌شده
دو Factory مجزا در سیستم تعریف شدند:

- **State Factory** برای ایجاد State مناسب بر اساس وضعیت Ticket
- **Strategy Factory** برای انتخاب Strategy مناسب بر اساس نوع Ticket

با این کار:
- وابستگی Stateها و Serviceها به پیاده‌سازی‌های concrete کاهش یافت
- تمرکز ایجاد اشیاء در یک محل مشخص انجام شد
- تغییر یا اضافه‌کردن State و Strategy جدید ساده‌تر شد

---

### جمع‌بندی فاز ۳
در این فاز، با اعمال الگوهای State، Strategy و Factory:
- منطق شرطی و پراکنده‌ی کد اولیه حذف شد
- مسئولیت‌ها بین کلاس‌ها به‌درستی تقسیم شدند
- سیستم از نظر طراحی شی‌گرا خواناتر، منعطف‌تر و قابل توسعه‌تر شد

این بازطراحی، پایه‌ی مناسبی برای تحلیل شی‌گرای انجام‌شده در فاز ۴ فراهم کرده است.
